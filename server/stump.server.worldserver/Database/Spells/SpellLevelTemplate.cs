using System;
using System.Collections.Generic;
using System.Linq;
using MongoDB.Bson.IO;
using NLog.Layouts;
using Stump.Core.IO;
using Stump.DofusProtocol.D2oClasses;
using Stump.DofusProtocol.D2oClasses.Tools.D2o;
using Stump.ORM;
using Stump.ORM.SubSonic.SQLGeneration.Schema;
using Stump.Server.WorldServer.Game.Effects;
using Stump.Server.WorldServer.Game.Effects.Instances;
using Stump.Server.WorldServer.Game.Spells;
using JsonConvert = Newtonsoft.Json.JsonConvert;

namespace Stump.Server.WorldServer.Database.Spells
{
    public class SpellLevelTemplateRelator
    {
        public static string FetchQuery = "SELECT * FROM spells_levels";
    }

    [TableName("spells_levels")]
    [D2OClass("SpellLevel", "com.ankamagames.dofus.datacenter.spells")]
    public class SpellLevelTemplate : IAssignedByD2O, ISaveIntercepter, IAutoGeneratedRecord
    {
        private List<EffectDice> m_criticalEffects;
        private byte[] m_criticalEffectsBin;
        private List<EffectDice> m_effects;
        private byte[] m_effectsBin;
        private SpellTemplate m_spell;
        private string m_statesForbiddenCSV;
        private string m_statesRequiredCSV;

        [PrimaryKey("Id", false)] public uint Id { get; set; }

        public uint SpellId { get; set; }

        public SpellTemplate Spell => m_spell ?? (m_spell = SpellManager.Instance.GetSpellTemplate((int) SpellId));

        public uint SpellBreed { get; set; }

        public uint ApCost { get; set; }

        public uint Range { get; set; }

        public bool CastInLine { get; set; }

        public bool CastInDiagonal { get; set; }

        public bool CastTestLos { get; set; }

        public uint CriticalHitProbability { get; set; }

        public string StatesRequiredCSV
        {
            get => m_statesRequiredCSV;
            set
            {
                m_statesRequiredCSV = value;
                StatesRequired = m_statesRequiredCSV.FromCSV<int>(",");
            }
        }

        [Ignore] public int[] StatesRequired { get; set; }

        public uint CriticalFailureProbability { get; set; }

        public bool NeedFreeCell { get; set; }

        public bool NeedFreeTrapCell { get; set; }

        public bool NeedTakenCell { get; set; }

        public bool RangeCanBeBoosted { get; set; }

        public int MaxStack { get; set; }

        public uint MaxCastPerTurn { get; set; }

        public uint MaxCastPerTarget { get; set; }

        public uint MinCastInterval { get; set; }

        public uint InitialCooldown { get; set; }

        public int GlobalCooldown { get; set; }

        public uint MinPlayerLevel { get; set; }

        public bool CriticalFailureEndsTurn { get; set; }

        public bool HideEffects { get; set; }

        public bool Hidden { get; set; }

        public uint MinRange { get; set; }

        public string StatesForbiddenCSV
        {
            get => m_statesForbiddenCSV;
            set
            {
                m_statesForbiddenCSV = value;
                StatesForbidden = value.FromCSV<int>(",");
            }
        }

        [Ignore] public int[] StatesForbidden { get; set; }

        public byte[] EffectsBin
        {
            get
            {
                return m_effectsBin;
            } 
            set
            {
                m_effectsBin = value;
                
                m_effects = EffectManager.Instance.DeserializeEffects(EffectsBin).Cast<EffectDice>().ToList();
            }
        }

        [Ignore]
        public List<EffectDice> Effects
        {
            get
            {
                return m_effects ??
                    (m_effects = EffectManager.Instance.DeserializeEffects(EffectsBin).Cast<EffectDice>().ToList());
            }
            set
            {
                m_effects = value;
            }
        }

        public byte[] CriticalEffectsBin
        {
            get => m_criticalEffectsBin;
            set
            {
                m_criticalEffectsBin = value;
                m_criticalEffects =
                    EffectManager.Instance.DeserializeEffects(CriticalEffectsBin).Cast<EffectDice>().ToList();
            }
        }

        [Ignore]
        public List<EffectDice> CriticalEffects
        {
            get =>
                m_criticalEffects ??
                (m_criticalEffects =
                    EffectManager.Instance.DeserializeEffects(CriticalEffectsBin).Cast<EffectDice>().ToList());
            set => m_criticalEffects = value;
        }

        public string AdditionalEffectsZonesCSV { get; set; }

        [Ignore]
        public List<string> AdditionalEffectsZones
        {
            get => AdditionalEffectsZonesCSV.Split(',').ToList();
            set => AdditionalEffectsZonesCSV = value.ToCSV(",");
        }

        public string StatesAuthorizedCSV { get; set; }

        [Ignore]
        public int[] StatesAuthorized
        {
            get { return StatesAuthorizedCSV.Split(',').Select(x => Convert.ToInt32(x)).ToArray(); }
            set => StatesAuthorizedCSV = value.ToCSV(",");
        }

        public SpellLevelTemplate()
        {
        }

        public SpellLevelTemplate(uint id, uint spellId, uint spellBreed, uint apCost, uint range, bool castInLine, bool castInDiagonal, bool castTestLos, uint criticalHitProbability, uint criticalFailureProbability, bool needFreeCell, bool needFreeTrapCell, bool needTakenCell, bool rangeCanBeBoosted, int maxStack, uint maxCastPerTurn, uint maxCastPerTarget, uint minCastInterval, uint initialCooldown, int globalCooldown, uint minPlayerLevel, bool hideEffects, bool hidden, uint minRange, string mStatesRequiredCsv, string mStatesForbiddenCsv, string additionalEffectsZonesCsv, string statesAuthorizedCsv, byte[] mCriticalEffectsBin, byte[] mEffectsBin)
        {
            Id = id;
            SpellId = spellId;
            SpellBreed = spellBreed;
            ApCost = apCost;
            Range = range;
            CastInLine = castInLine;
            CastInDiagonal = castInDiagonal;
            CastTestLos = castTestLos;
            CriticalHitProbability = criticalHitProbability;
            CriticalFailureProbability = criticalFailureProbability;
            NeedFreeCell = needFreeCell;
            NeedFreeTrapCell = needFreeTrapCell;
            NeedTakenCell = needTakenCell;
            RangeCanBeBoosted = rangeCanBeBoosted;
            MaxStack = maxStack;
            MaxCastPerTurn = maxCastPerTurn;
            MaxCastPerTarget = maxCastPerTarget;
            MinCastInterval = minCastInterval;
            InitialCooldown = initialCooldown;
            GlobalCooldown = globalCooldown;
            MinPlayerLevel = minPlayerLevel;
            HideEffects = hideEffects;
            Hidden = hidden;
            MinRange = minRange;
            m_statesRequiredCSV = mStatesRequiredCsv;
            m_statesForbiddenCSV = mStatesForbiddenCsv;
            AdditionalEffectsZonesCSV = additionalEffectsZonesCsv;
            StatesAuthorizedCSV = statesAuthorizedCsv;
            m_criticalEffectsBin = mCriticalEffectsBin;
            m_effectsBin = mEffectsBin;
        }

        #region IAssignedByD2O Members

        public void AssignFields(object d2oObject)
        {
            var spell = (SpellLevel) d2oObject;

            Id = spell.id;
            SpellId = spell.spellId;
            SpellBreed = spell.spellBreed;
            ApCost = spell.apCost;
            MinRange = spell.minRange;
            Range = spell.range;
            CastInLine = spell.castInLine;
            CastInDiagonal = spell.castInDiagonal;
            CastTestLos = spell.castTestLos;
            CriticalHitProbability = spell.criticalHitProbability;
            NeedFreeCell = spell.needFreeCell;
            NeedTakenCell = spell.needTakenCell;
            NeedFreeTrapCell = spell.needFreeTrapCell;
            RangeCanBeBoosted = spell.rangeCanBeBoosted;
            MaxStack = spell.maxStack;
            MaxCastPerTurn = spell.maxCastPerTurn;
            MaxCastPerTarget = spell.maxCastPerTarget;
            MinCastInterval = spell.minCastInterval;
            InitialCooldown = spell.initialCooldown;
            GlobalCooldown = spell.globalCooldown;
            MinPlayerLevel = spell.minPlayerLevel;
            HideEffects = spell.hideEffects;
            Hidden = spell.hidden;
            StatesRequired = spell.statesRequired.ToArray();
            StatesAuthorized = spell.statesAuthorized.ToArray();
            StatesForbidden = spell.statesForbidden.ToArray();
            AdditionalEffectsZones = spell.AdditionalEffectsZones;
            m_effectsBin = EffectManager.Instance.SerializeEffects(spell.effects);
            m_criticalEffectsBin = EffectManager.Instance.SerializeEffects(spell.criticalEffect);
        }

        #endregion

        #region ISaveIntercepter Members

        public void BeforeSave(bool insert)
        {
            m_statesForbiddenCSV = StatesForbidden.ToCSV(",");
            m_statesRequiredCSV = StatesRequired.ToCSV(",");
            //m_effectsBin = EffectManager.Instance.SerializeEffects(Effects);
            // m_criticalEffectsBin = EffectManager.Instance.SerializeEffects(CriticalEffects);
        }

        #endregion
    }
}